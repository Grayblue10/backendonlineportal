import mongoose from 'mongoose';
import asyncHandler from '../utils/asyncHandler.js';
import ErrorResponse from '../utils/errorResponse.js';
import Student from '../models/Student.model.js';
import User from '../models/User.model.js';
import Grade from '../models/Grade.model.js';
import Class from '../models/Class.model.js';
import Assignment from '../models/Assignment.model.js';
import Attendance from '../models/Attendance.model.js';
import Announcement from '../models/Announcement.model.js';
import Subject from '../models/Subject.model.js';



/**
 * @desc    Get all students
 * @route   GET /api/students
 * @access  Private/Admin
 */
const getStudents = asyncHandler(async (req, res, next) => {
  // Only admins can list all students
  if (req.user.role !== 'admin') {
    throw ErrorResponse.forbidden('Not authorized to access this route');
  }
  
  const students = await Student.find().select('-password');
  res.status(200).json({ 
    success: true, 
    count: students.length, 
    data: students 
  });
});

/**
 * @desc    Get single student
 * @route   GET /api/students/:id
 * @access  Private/Admin
 */
const getStudent = asyncHandler(async (req, res, next) => {
  const student = await Student.findById(req.params.id).select('-password');
  
  if (!student) {
    throw ErrorResponse.notFound(`Student with id ${req.params.id} not found`);
  }
  
  // Make sure user is the student or admin
  if (student._id.toString() !== req.user.id && req.user.role !== 'admin') {
    throw ErrorResponse.forbidden('Not authorized to access this student');
  }
  
  res.status(200).json({ success: true, data: student });
});

/**
 * @desc    Create student
 * @route   POST /api/students
 * @access  Private/Admin
 */
const createStudent = asyncHandler(async (req, res, next) => {
  // Only admins can create students
  if (req.user.role !== 'admin') {
    return next(new ErrorResponse('Not authorized to create students', 403));
  }

  // Check if email already exists
  const existingStudent = await Student.findOne({ email: req.body.email });
  if (existingStudent) {
    return next(new ErrorResponse('Email already in use', 400));
  }

  const student = await Student.create({
    email: req.body.email,
    password: req.body.password,
    fullName: req.body.fullName,
    firstName: req.body.firstName,
    lastName: req.body.lastName
    // studentId will be auto-generated by the pre-save hook
  });
  
  // Remove password from response
  const studentResponse = student.toObject();
  delete studentResponse.password;
  
  res.status(201).json({ 
    success: true, 
    message: 'Student created successfully',
    data: studentResponse 
  });
});

/**
 * @desc    Update student
 * @route   PUT /api/students/:id
 * @access  Private/Admin
 */
const updateStudent = asyncHandler(async (req, res, next) => {
  let student = await Student.findById(req.params.id);

  if (!student) {
    throw ErrorResponse.notFound(`Student with id ${req.params.id} not found`);
  }

  // Make sure user is the student or admin
  if (student._id.toString() !== req.user.id && req.user.role !== 'admin') {
    throw ErrorResponse.forbidden('Not authorized to update this student');
  }

  // Fields that can be updated
  const updatableFields = [
    'fullName', 'contactNumber', 'address', 'grade', 'section'
  ];
  
  // Only admins can update these fields
  if (req.user.role === 'admin') {
    updatableFields.push('email', 'studentId', 'isActive');
  }

  // Build update object
  const updateData = {};
  updatableFields.forEach(field => {
    if (req.body[field] !== undefined) {
      updateData[field] = req.body[field];
    }
  });

  // Update password if provided
  if (req.body.password) {
    student.password = req.body.password;
    await student.save();
  }

  student = await Student.findByIdAndUpdate(req.params.id, updateData, {
    new: true,
    runValidators: true
  }).select('-password');

  res.status(200).json({ success: true, data: student });
});

/**
 * @desc    Delete student
 * @route   DELETE /api/students/:id
 * @access  Private/Admin
 */
const deleteStudent = asyncHandler(async (req, res, next) => {
  const student = await Student.findById(req.params.id);

  if (!student) {
    throw ErrorResponse.notFound(`Student with id ${req.params.id} not found`);
  }

  await student.remove();

  res.status(200).json({ 
    success: true, 
    message: 'Student deleted successfully',
    data: {} 
  });
});

/**
 * @desc    Get student dashboard data
 * @route   GET /api/students/dashboard
 * @access  Private/Student
 */
const getStudentDashboard = asyncHandler(async (req, res, next) => {
  const sessionId = req.headers['x-request-id'] || Math.random().toString(36).substring(7);
  
  const log = (message, data = {}) => {
    console.log(`[${new Date().toISOString()}] [${sessionId}] ${message}`, Object.keys(data).length ? data : '');
  };
  
  try {
    log('Fetching dashboard data', { userId: req.user?.id });
    
    if (!req.user) {
      log('No user found in request');
      return next(new ErrorResponse('Authentication required', 401));
    }
    
    // Validate student exists
    const student = await Student.findById(req.user.id).lean();
    if (!student) {
      log('Student profile not found', { userId: req.user.id });
      return next(new ErrorResponse('Student profile not found. Please complete your profile.', 404));
    }
    
    log('Student found', { studentId: student._id, name: `${student.firstName} ${student.lastName}` });
    
    // Initialize default response structure
    const responseData = {
      stats: {
        totalSubjects: 0,
        averageGrade: 0,
        attendanceRate: 0,
        upcomingAssignments: 0,
        gpa: 0.0,
        enrolledSubjects: 0,
        completedAssignments: 0,
        upcomingTests: 0
      },
      recentGrades: [],
      upcomingClasses: [],
      announcements: []
    };
    
    // Get recent grades with error handling
    try {
      log('Fetching recent grades');
      const grades = await Grade.find({ student: student._id })
        .sort({ updatedAt: -1 })
        .limit(5)
        .populate('subject', 'name code')
        .populate('gradedBy', 'firstName lastName')
        .lean()
        .catch(err => {
          log('Error in grade query', { error: err.message });
          return [];
        });
      
      log(`Found ${grades.length} grades`);
      
      if (grades.length > 0) {
        const validGrades = grades.filter(g => g?.score !== undefined && g?.maxScore);
        if (validGrades.length > 0) {
          const totalPercentage = validGrades.reduce((sum, grade) => {
            return sum + (grade.score / grade.maxScore) * 100;
          }, 0);
          
          responseData.stats.averageGrade = parseFloat((totalPercentage / validGrades.length).toFixed(2));
          responseData.stats.gpa = parseFloat((totalPercentage / validGrades.length / 100 * 4.0).toFixed(2));
        }
        
        responseData.recentGrades = grades.map(grade => ({
          _id: grade._id,
          subject: grade.subject || { name: 'Unknown', code: 'N/A' },
          score: grade.score,
          maxScore: grade.maxScore,
          type: grade.type || 'Assignment',
          date: grade.updatedAt,
          gradedBy: grade.gradedBy || { firstName: 'Teacher', lastName: '' },
          feedback: grade.feedback || '',
          status: grade.status || 'Graded'
        }));
      }
    } catch (error) {
      log('Error processing grades', { error: error.message });
    }

    // Get enrolled subjects from Class model where student is enrolled
    let enrolledSubjects = [];
    try {
      console.log(`[StudentDashboard] Fetching enrolled classes for student`);
      const enrolledClasses = await Class.find({ 
        students: student._id 
      }).populate('subject', 'name code units');
      
      enrolledSubjects = enrolledClasses.map(cls => cls.subject).filter(Boolean);
      responseData.stats.enrolledSubjects = enrolledSubjects.length;
      console.log(`[StudentDashboard] Found ${enrolledSubjects.length} enrolled subjects`);
    } catch (error) {
      console.error('[StudentDashboard] Error fetching enrolled subjects:', error.message);
    }

    // Get student's classes from Class model where student is enrolled
    let studentClasses = [];
    try {
      const enrolledClasses = await Class.find({ 
        students: student._id 
      }).select('_id');
      studentClasses = enrolledClasses.map(cls => cls._id);
      console.log(`[StudentDashboard] Student enrolled in ${studentClasses.length} classes`);
    } catch (error) {
      console.error('[StudentDashboard] Error fetching student classes:', error.message);
    }

    // Calculate assignment completion stats
    try {
      const completedAssignments = await Assignment.countDocuments({
        class: { $in: studentClasses },
        'submissions.student': student._id,
        'submissions.submitted': true
      });
      
      const totalAssignments = await Assignment.countDocuments({
        class: { $in: studentClasses },
        dueDate: { $lte: new Date() }
      });
      
      responseData.stats.completedAssignments = completedAssignments;
      responseData.stats.upcomingTests = Math.max(0, totalAssignments - completedAssignments);
      
      console.log(`[StudentDashboard] Assignment stats: ${completedAssignments}/${totalAssignments} completed`);
    } catch (error) {
      console.error('[StudentDashboard] Error calculating assignment stats:', error.message);
    }

    // Calculate attendance rate
    try {
      const attendanceRecords = await Attendance.find({ 
        student: student._id,
        date: { $gte: new Date(new Date().setDate(new Date().getDate() - 30)) }
      });
      
      if (attendanceRecords.length > 0) {
        const presentCount = attendanceRecords.filter(record => record.status === 'present').length;
        responseData.stats.attendanceRate = Math.round((presentCount / attendanceRecords.length) * 100);
      }
      
      console.log(`[StudentDashboard] Attendance rate: ${responseData.stats.attendanceRate}%`);
    } catch (error) {
      console.error('[StudentDashboard] Error calculating attendance:', error.message);
    }

    // Get upcoming classes with comprehensive error handling
    try {
      log('Fetching upcoming classes');
      const now = new Date();
      const endOfDay = new Date();
      endOfDay.setHours(23, 59, 59, 999);
      
      const studentClasses = await Class.find({
        students: student._id,
        'schedule.startTime': { $gte: now, $lte: endOfDay },
        status: 'active'
      })
      .populate('subject', 'name code')
      .populate('teacher', 'firstName lastName')
      .sort('schedule.startTime')
      .limit(5)
      .lean()
      .catch(err => {
        log('Error in class query', { error: err.message });
        return [];
      });
      
      log(`Found ${studentClasses.length} upcoming classes`);
      
      responseData.upcomingClasses = studentClasses.map(classItem => ({
        _id: classItem._id,
        subject: classItem.subject || { name: 'Unknown', code: 'N/A' },
        title: classItem.title || 'Class',
        description: classItem.description || '',
        startTime: classItem.schedule?.startTime || new Date(),
        endTime: classItem.schedule?.endTime || new Date(),
        teacher: classItem.teacher || { firstName: 'Teacher', lastName: '' },
        meetingLink: classItem.meetingLink || null,
        isOnline: classItem.isOnline || false,
        room: classItem.room || 'TBD'
      }));
      
      // Get enrolled subjects count
      try {
        const enrolledCount = await Class.countDocuments({
          students: student._id,
          status: 'active'
        });
        responseData.stats.enrolledSubjects = enrolledCount;
        responseData.stats.totalSubjects = enrolledCount;
      } catch (countError) {
        log('Error counting enrolled subjects', { error: countError.message });
      }
      
      // Get upcoming assignments count
      try {
        const classIds = studentClasses.map(c => c._id);
        if (classIds.length > 0) {
          const upcomingCount = await Assignment.countDocuments({
            class: { $in: classIds },
            dueDate: { $gte: now },
            status: 'published'
          });
          responseData.stats.upcomingAssignments = upcomingCount;
          responseData.stats.upcomingTests = upcomingCount;
        }
      } catch (assignmentError) {
        log('Error counting upcoming assignments', { error: assignmentError.message });
      }
      
    } catch (error) {
      log('Error processing upcoming classes', { error: error.message });
    }

    // Get attendance data if needed
    try {
      log('Fetching attendance data');
      const threeMonthsAgo = new Date();
      threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
      
      const attendanceRecords = await Attendance.find({
        student: student._id,
        date: { $gte: threeMonthsAgo }
      }).lean().catch(() => []);
      
      if (attendanceRecords.length > 0) {
        const presentCount = attendanceRecords.filter(r => r.status === 'present').length;
        responseData.stats.attendanceRate = Math.round((presentCount / attendanceRecords.length) * 100);
      }
      
    } catch (error) {
      log('Error processing attendance data', { error: error.message });
    }
    
    // Calculate completed assignments if not already set
    if (!responseData.stats.completedAssignments) {
      try {
        const completedCount = await Assignment.countDocuments({
          'submissions.student': student._id,
          'submissions.submittedAt': { $exists: true }
        }).catch(() => 0);
        responseData.stats.completedAssignments = completedCount;
      } catch (error) {
        log('Error counting completed assignments', { error: error.message });
      }
    }
    
    // Ensure all stats are numbers
    Object.keys(responseData.stats).forEach(key => {
      if (typeof responseData.stats[key] === 'string') {
        responseData.stats[key] = parseFloat(responseData.stats[key]) || 0;
      }
    });
    
    log('Sending dashboard response', {
      stats: responseData.stats,
      gradesCount: responseData.recentGrades.length,
      classesCount: responseData.upcomingClasses.length,
      announcementsCount: responseData.announcements.length
    });
    
    res.status(200).json({
      success: true,
      data: responseData
    });
    
  } catch (error) {
    log('Critical error in getStudentDashboard', { 
      error: error.message, 
      stack: error.stack 
    });
    
    // Send a minimal response with error details in development
    const errorResponse = {
      success: false,
      error: process.env.NODE_ENV === 'development' ? error.message : 'Failed to load dashboard data',
      ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
    };
    
    res.status(500).json(errorResponse);
  }
});

// Helper function to calculate letter grade
const calculateLetterGrade = (score, maxScore) => {
  if (!score || !maxScore) return 'N/A';
  
  const percentage = (score / maxScore) * 100;
  
  if (percentage >= 97) return 'A+';
  if (percentage >= 93) return 'A';
  if (percentage >= 90) return 'A-';
  if (percentage >= 87) return 'B+';
  if (percentage >= 83) return 'B';
  if (percentage >= 80) return 'B-';
  if (percentage >= 77) return 'C+';
  if (percentage >= 73) return 'C';
  if (percentage >= 70) return 'C-';
  if (percentage >= 67) return 'D+';
  if (percentage >= 65) return 'D';
  return 'F';
};

/**
 * @desc    Get student profile
 * @route   GET /api/student/profile
 * @access  Private/Student
 */
const getStudentProfile = asyncHandler(async (req, res, next) => {
  const student = await Student.findById(req.user.id)
    .select('-password');

  if (!student) {
    return next(new ErrorResponse('Student profile not found', 404));
  }

  res.status(200).json({
    success: true,
    data: {
      ...student._doc,
      email: req.user.email
    }
  });
});

// @desc    Get student grades
// @route   GET /api/student/grades
// Helper function to calculate average grade for a student
const calculateAverageGrade = async (studentId) => {
  const grades = await Grade.find({ student: studentId });
  
  if (!grades || grades.length === 0) {
    return 0;
  }
  
  const total = grades.reduce((sum, grade) => {
    if (grade.score && typeof grade.score === 'number') {
      return sum + (grade.score / (grade.maxScore || 100)) * 100;
    }
    return sum;
  }, 0);
  
  return Math.round((total / grades.length) * 100) / 100; // Round to 2 decimal places
};

/**
 * @desc    Get student grades
 * @route   GET /api/student/grades
 * @access  Private/Student
 */
const getStudentGrades = asyncHandler(async (req, res, next) => {
  console.log(`[getStudentGrades] Fetching grades for user ${req.user.id}`);
  
  const student = await Student.findById(req.user.id);
  
  if (!student) {
    console.error(`[getStudentGrades] Student profile not found for user ${req.user.id}`);
    return next(new ErrorResponse('Student profile not found', 404));
  }

  console.log(`[getStudentGrades] Found student: ${student.firstName} ${student.lastName}`);

  try {
    // Get all grades for the student
    // Note: subject is embedded (not a ref), so do not populate it
    const grades = await Grade.find({ student: student._id })
      // Avoid populate for non-ref fields to prevent StrictPopulateError
      .sort('-updatedAt');

    console.log(`[getStudentGrades] Found ${grades.length} grades`);

    // Helper: convert percentage to numeric grade (1.00–5.00)
    const percentToNumeric = (p) => {
      if (p === null || p === undefined || Number.isNaN(p)) return null;
      if (p >= 98) return 1.00;
      if (p >= 95) return 1.25;
      if (p >= 92) return 1.50;
      if (p >= 89) return 1.75;
      if (p >= 86) return 2.00;
      if (p >= 83) return 2.25;
      if (p >= 80) return 2.50;
      if (p >= 77) return 2.75;
      if (p >= 75) return 3.00;
      return 5.00;
    };

    // Transform grades to match frontend expectations (using numeric final grades)
    const transformedGrades = grades.map(grade => {
      const isFinal = (grade.assessmentType || grade.type) === 'final';
      const rawScore = typeof grade.score === 'number' ? grade.score : null;
      const rawMax = typeof grade.maxScore === 'number' && grade.maxScore > 0 ? grade.maxScore : null;

      // Determine percentage
      let percent = (grade.finalGrade && typeof grade.finalGrade.percentage === 'number')
        ? grade.finalGrade.percentage
        : null;

      if (percent === null) {
        if (isFinal && rawScore !== null && rawScore >= 1 && rawScore <= 5) {
          // Numeric final (1..5) -> percentage
          percent = Math.round(((5 - rawScore) / 4) * 100);
        } else if (rawScore !== null && rawMax) {
          percent = Math.round((rawScore / rawMax) * 100);
        }
      }

      // Determine numeric (1.00..5.00)
      let numeric = null;
      if (isFinal && rawScore !== null && rawScore >= 1 && rawScore <= 5) {
        numeric = Number(rawScore);
      } else if (typeof grade.numericGrade === 'number') {
        numeric = grade.numericGrade;
      } else {
        numeric = percentToNumeric(percent);
      }

      const teacherName = (grade.gradedBy && typeof grade.gradedBy === 'object' && grade.gradedBy.firstName)
        ? `${grade.gradedBy.firstName} ${grade.gradedBy.lastName || ''}`.trim()
        : 'Unknown Teacher';

      return {
        _id: grade._id,
        subject: grade.subject || { name: 'Unknown Subject', code: 'N/A' },
        assessmentType: grade.assessmentType || grade.type || 'final',
        title: grade.title || 'Assessment',
        // Expose the numeric grade on `score` for the Student UI
        score: typeof numeric === 'number' ? Number(numeric.toFixed(2)) : null,
        maxScore: null,
        percentage: percent,
        grade: grade.finalGrade?.letterGrade || grade.letterGrade || null,
        semester: grade.semester || 'first',
        academicYear: grade.academicYear || '2024-25',
        gradedAt: grade.updatedAt || grade.createdAt,
        gradedBy: grade.gradedBy || null,
        feedback: grade.feedback || '',
        teacher: teacherName
      };
    });

    // Calculate stats without relying on maxScore
    const toPercentage = (g) => {
      if (typeof g.percentage === 'number' && !Number.isNaN(g.percentage)) {
        return g.percentage;
      }
      if (typeof g.score === 'number' && !Number.isNaN(g.score)) {
        // Convert numeric final grade (1.00 best – 5.00 fail) to percentage (100 best – 0 worst)
        const clamped = Math.max(1, Math.min(5, g.score));
        return Math.round(((5 - clamped) / 4) * 100);
      }
      return null;
    };

    const pctValues = transformedGrades
      .map(toPercentage)
      .filter(v => typeof v === 'number' && !Number.isNaN(v));

    const averageScore = pctValues.length > 0
      ? pctValues.reduce((a, b) => a + b, 0) / pctValues.length
      : 0;
    const gpa = averageScore / 100 * 4.0;
    const highestPct = pctValues.length > 0 ? Math.max(...pctValues) : 0;
    const highestGrade = calculateLetterGrade(highestPct, 100);

    console.log(`[getStudentGrades] Returning ${transformedGrades.length} transformed grades`);

    res.status(200).json({
      success: true,
      data: {
        grades: transformedGrades,
        stats: {
          gpa: parseFloat(gpa.toFixed(2)),
          totalGrades: transformedGrades.length,
          averageScore: parseFloat(averageScore.toFixed(1)),
          highestGrade: highestGrade
        }
      }
    });

  } catch (error) {
    console.error(`[getStudentGrades] Error:`, error);
    return next(new ErrorResponse('Failed to fetch grades', 500));
  }
});

// @desc    Update student profile
// @route   PUT /api/student/profile
// @access  Private/Student
const updateStudentProfile = asyncHandler(async (req, res, next) => {
  const student = await Student.findById(req.user.id);
  
  if (!student) {
    throw ErrorResponse.notFound('Student profile not found');
  }

  // Fields that can be updated
  const updates = {};
  const allowedUpdates = ['fullName', 'contactNumber', 'address', 'dateOfBirth'];
  
  // Filter updates to only include allowed fields
  Object.keys(req.body).forEach(key => {
    if (allowedUpdates.includes(key)) {
      updates[key] = req.body[key];
    }
  });

  // Update student profile
  const updatedStudent = await Student.findByIdAndUpdate(
    student._id,
    { $set: updates },
    { new: true, runValidators: true }
  ).select('-password');

  res.status(200).json({
    success: true,
    message: 'Profile updated successfully',
    data: updatedStudent
  });
});

// @desc    Get recent grades for student
// @route   GET /api/student/grades/recent
// @access  Private/Student
const getRecentGrades = asyncHandler(async (req, res, next) => {
  const student = await Student.findById(req.user.id);
  
  if (!student) {
    console.error(`Student profile not found for user ${req.user.id} when fetching grades`);
    throw ErrorResponse.notFound('Please complete your student profile setup');
  }

  // Get recent grades (last 5)
  const recentGrades = await Grade.find({ student: student._id })
    .sort('-updatedAt')
    .limit(5);

  res.status(200).json({
    success: true,
    data: recentGrades
  });
});

// @desc    Get academic progress for student
// @route   GET /api/student/progress
// @access  Private/Student
const getAcademicProgress = asyncHandler(async (req, res, next) => {
  const student = await Student.findById(req.user.id);
  
  if (!student) {
    console.error(`Student profile not found for user ${req.user.id} when fetching academic progress`);
    throw ErrorResponse.notFound('Please complete your student profile setup');
  }

  // Get all grades for the student
  const grades = await Grade.find({ student: student._id })
    .populate('subject', 'name code');

  // Calculate overall progress
  const totalSubjects = await Grade.distinct('subject', { student: student._id });
  const completedSubjects = await Grade.distinct('subject', { 
    student: student._id,
    'finalGrade.percentage': { $gte: 60 } // Consider 60% as passing
  });

  // Calculate average grade
  const totalPercentage = grades.reduce((sum, grade) => 
    sum + (grade.finalGrade?.percentage || 0), 0);
  const averageGrade = grades.length > 0 ? (totalPercentage / grades.length).toFixed(2) : 0;

  // Calculate by subject
  const progressBySubject = [];
  const subjectMap = new Map();
  
  grades.forEach(grade => {
    if (!subjectMap.has(grade.subject._id.toString())) {
      subjectMap.set(grade.subject._id.toString(), {
        subject: grade.subject,
        grades: [],
        average: 0
      });
    }
    const subjectData = subjectMap.get(grade.subject._id.toString());
    subjectData.grades.push(grade);
  });

  // Calculate average for each subject
  subjectMap.forEach(subjectData => {
    const total = subjectData.grades.reduce(
      (sum, grade) => sum + (grade.finalGrade?.percentage || 0), 0
    );
    subjectData.average = subjectData.grades.length > 0 
      ? (total / subjectData.grades.length).toFixed(2)
      : 0;
    
    progressBySubject.push({
      subject: subjectData.subject,
      average: subjectData.average,
      gradeCount: subjectData.grades.length
    });
  });

  res.status(200).json({
    success: true,
    data: {
      student: {
        id: student._id,
        fullName: student.fullName,
        studentId: student.studentId
      },
      overallProgress: {
        totalSubjects: totalSubjects.length,
        completedSubjects: completedSubjects.length,
        completionRate: totalSubjects.length > 0 
          ? Math.round((completedSubjects.length / totalSubjects.length) * 100) 
          : 0,
        averageGrade: parseFloat(averageGrade)
      },
      progressBySubject
    }
  });
});

/**
 * @desc    Get student's subjects
 * @route   GET /api/student/subjects
 * @access  Private/Student
 */
const getStudentSubjects = asyncHandler(async (req, res, next) => {
  console.log(`[getStudentSubjects] Fetching subjects for user ${req.user.id}`);
  
  const student = await Student.findById(req.user.id);
  
  if (!student) {
    console.error(`[getStudentSubjects] Student profile not found for user ${req.user.id}`);
    return next(new ErrorResponse('Student profile not found', 404));
  }

  console.log(`[getStudentSubjects] Found student: ${student.firstName} ${student.lastName}`);

  try {
    // Get all classes/subjects the student is enrolled in
    const classes = await Class.find({ students: student._id })
      .populate('subject', 'name code description units semester department')
      .populate('teacher', 'firstName lastName email');

    console.log(`[getStudentSubjects] Found ${classes.length} enrolled classes`);

    // If no classes found, return empty real dataset (no mock data)
    if (classes.length === 0) {
      console.log(`[getStudentSubjects] No enrolled classes found, returning empty subjects array`);
      return res.status(200).json({ success: true, count: 0, data: [] });
    }

    // Transform data to match frontend expectations
    const subjects = await Promise.all(classes.map(async (cls) => {
      if (!cls?.schedule || (!Array.isArray(cls.schedule.days) || cls.schedule.days.length === 0)) {
        console.warn('[getStudentSubjects] Class has no days in schedule:', {
          classId: cls._id?.toString?.(),
          classCode: cls.code,
          subject: cls.subject?.code,
          schedule: cls.schedule
        });
      }
      // Get grades for this subject to calculate current grade and average
      // Grade.subject is embedded, match by subject.code to ensure accuracy
      const subjectGrades = await Grade.find({ 
        student: student._id, 
        'subject.code': cls.subject.code 
      });
      
      let currentGrade = 'N/A';
      let averageScore = 0;
      
      if (subjectGrades.length > 0) {
        const toPct = (g) => {
          if (g?.finalGrade && typeof g.finalGrade.percentage === 'number') return g.finalGrade.percentage;
          if ((g.assessmentType || g.type) === 'final' && typeof g.score === 'number' && g.score >= 1 && g.score <= 5) {
            return Math.round(((5 - g.score) / 4) * 100);
          }
          if (typeof g.score === 'number' && typeof g.maxScore === 'number' && g.maxScore > 0) {
            return Math.round((g.score / g.maxScore) * 100);
          }
          return null;
        };
        const pctValues = subjectGrades.map(toPct).filter(v => typeof v === 'number');
        const totalPercentage = pctValues.reduce((sum, v) => sum + v, 0);
        averageScore = pctValues.length > 0 ? Math.round(totalPercentage / pctValues.length) : 0;
        currentGrade = calculateLetterGrade(averageScore, 100);
      }
      
      // Get assignments for this class
      const assignments = await Assignment.find({ class: cls._id });
      const completedAssignments = assignments.filter(a => 
        a.submissions && a.submissions.some(s => 
          s.student.toString() === student._id.toString() && s.submitted
        )
      ).length;
      
      // Get next upcoming assignment
      const upcomingAssignments = assignments.filter(a => 
        a.dueDate > new Date() && 
        (!a.submissions || !a.submissions.some(s => 
          s.student.toString() === student._id.toString() && s.submitted
        ))
      ).sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
      
      const nextAssignment = upcomingAssignments[0];
      
      return {
        id: cls.subject._id,
        _id: cls.subject._id,
        name: cls.subject.name,
        code: cls.subject.code,
        description: cls.subject.description || 'No description available',
        units: cls.subject.units || 3,
        semester: cls.subject.semester || 'first',
        department: cls.subject.department || 'General',
        teacher: {
          name: cls.teacher ? `${cls.teacher.firstName} ${cls.teacher.lastName}` : 'TBA',
          email: cls.teacher?.email || ''
        },
        teacherName: cls.teacher ? `${cls.teacher.firstName} ${cls.teacher.lastName}` : 'TBA',
        schedule: (cls.schedule && Array.isArray(cls.schedule.days) && cls.schedule.days.length)
          ? `${cls.schedule.days.join(', ')} ${cls.schedule.startTime || ''}${(cls.schedule.startTime && cls.schedule.endTime) ? ' - ' : ''}${cls.schedule.endTime || ''}`.trim() || 'Schedule TBA'
          : 'Schedule TBA',
        room: cls.schedule?.room || 'Room TBA',
        // expose raw schedule for debugging/frontend fallback
        rawSchedule: cls.schedule || null,
        currentGrade: currentGrade,
        averageScore: averageScore,
        completedAssignments: completedAssignments,
        totalAssignments: assignments.length,
        nextAssignment: nextAssignment?.title || null,
        nextAssignmentDue: nextAssignment?.dueDate || null,
        isEnrolled: true
      };
    }));

    console.log(`[getStudentSubjects] Returning ${subjects.length} transformed subjects`);

    res.status(200).json({
      success: true,
      count: subjects.length,
      data: subjects
    });

  } catch (error) {
    console.error(`[getStudentSubjects] Error:`, error);
    return next(new ErrorResponse('Failed to fetch subjects', 500));
  }
});

/**
 * @desc    Change student password
 * @route   PUT /api/student/change-password
 * @access  Private/Student
 */
const changePassword = asyncHandler(async (req, res, next) => {
  const { currentPassword, newPassword } = req.body;
  
  const student = await Student.findById(req.user.id).select('+password');
  
  if (!student) {
    throw ErrorResponse.notFound('Student profile not found');
  }

  // Check current password
  const isCurrentPasswordCorrect = await student.matchPassword(currentPassword);
  if (!isCurrentPasswordCorrect) {
    throw ErrorResponse.unauthorized('Current password is incorrect');
  }

  // Update password
  student.password = newPassword;
  await student.save();

  res.status(200).json({
    success: true,
    message: 'Password updated successfully'
  });
});

// Export all student controller functions
export {
  getStudents,
  getStudent,
  createStudent,
  updateStudent,
  getStudentDashboard,
  getStudentProfile,
  updateStudentProfile,
  getStudentGrades,
  getStudentSubjects,
  getRecentGrades,
  getAcademicProgress,
  changePassword,
  deleteStudent
};
